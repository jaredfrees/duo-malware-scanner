/*
  A kernel module to list process by their names. Print when loading the module.
  In the terminal, compile this module with "make" and load it with "sudo insmod process.ko". 
  Check the result of printk by “dmesg”
  Unload it with "sudo rmmod process.ko".
*/

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/init.h>
#include <linux/sched.h>
#include <asm/unistd.h>
#include <linux/list.h>
#include <linux/init_task.h>
#include <linux/syscalls.h>
#include <linux/kallsyms.h>

#include "print_to_tty.c"

#ifndef __KERNEL__
#define __KERNEL__
#endif

#define SYS_CALL_TABLE "sys_call_table"
#define SYSCALL_NI __NR_tuxcall
#define SYSCALL_NJ __NR_mlockall

static unsigned long *syscall_table = NULL;

static unsigned long *original_syscall1 = NULL;
static unsigned long *original_syscall2 = NULL;
//asmlinkage long (*original_syscall) (const char *);

static char taskNameCheck[40];
static char memoryNameCheck[40];

// Print all running processes with their names
static unsigned long print_task_by_name(const char *str) {

  // The struct used for info of a process
  struct task_struct* task;
  
  if (copy_from_user(taskNameCheck, str, 40)) {
    return -EFAULT;
  }
  taskNameCheck[39] = 0;

  // Go over through the list of processes
  for_each_process(task) {
    //printk("Task: %s", (task->comm));
    //printk("Task length: %ld , str length: %ld", (strlen(task->comm)), strlen(taskNameCheck));
    if (!(strcmp((task->comm), taskNameCheck))) {
      printk("Found matching process: %s, PID: %d\n", task->comm, task->pid);
      print_string(taskNameCheck);
    }
  }

  return 0;
}

static unsigned long scan_memory(const char *str) {
  //struct task_struct* task;
  
  if (copy_from_user(memoryNameCheck, str, 40)) {
    return -EFAULT;
  }
  memoryNameCheck[39] = 0;

  printk("***scan_memory fucntion***");

  return 0;
}

static int is_syscall_table(ulong *p)
{
  return ((p != NULL) && (p[__NR_close] == (ulong)sys_close));
}

static int page_read_write(ulong address)
{
  uint level;
  pte_t *pte = lookup_address(address, &level);

  if(pte->pte &~ _PAGE_RW)
          pte->pte |= _PAGE_RW;
  return 0;
}

static int page_read_only(ulong address)
{
  uint level;
  pte_t *pte = lookup_address(address, &level);
  pte->pte = pte->pte &~ _PAGE_RW;
  return 0;
}

static void replace_syscall1(ulong offset, ulong func_address)
{
  syscall_table = (ulong *)kallsyms_lookup_name(SYS_CALL_TABLE);
  if (is_syscall_table(syscall_table)) {
    printk(KERN_INFO "Syscall table address : %p\n", syscall_table);
    page_read_write((ulong)syscall_table);

    original_syscall1 = (ulong *)(syscall_table[offset]);
    printk(KERN_INFO "Syscall at offset %lu : %p\n", offset, original_syscall1);
    printk(KERN_INFO "Custom syscall address %p\n", (void *)func_address);
    
    syscall_table[offset] = func_address;
    
    printk(KERN_INFO "Syscall hijacked\n");
    printk(KERN_INFO "Syscall at offset %lu : %p\n", offset, (void *)syscall_table[offset]);
    page_read_only((ulong)syscall_table);
  }
}

static void replace_syscall2(ulong offset, ulong func_address)
{
  syscall_table = (ulong *)kallsyms_lookup_name(SYS_CALL_TABLE);
  if (is_syscall_table(syscall_table)) {
    printk(KERN_INFO "Syscall table address : %p\n", syscall_table);
    page_read_write((ulong)syscall_table);

    original_syscall2 = (ulong *)(syscall_table[offset]);
    printk(KERN_INFO "Syscall at offset %lu : %p\n", offset, (void *)original_syscall2);
    printk(KERN_INFO "Custom syscall address %p\n", (void *)func_address);
    
    syscall_table[offset] = func_address;
    
    printk(KERN_INFO "Syscall hijacked\n");
    printk(KERN_INFO "Syscall at offset %lu : %p\n", offset, (void *)syscall_table[offset]);
    page_read_only((ulong)syscall_table);
  }
}


// Initialization of module
static int __init init_MalwareModule(void)
{  
  printk(KERN_INFO "INIT Malware Scanner Kernal Module.\n");
  
  print_string("The module has been inserted");
  //printk("%d", print_task_by_name);
  replace_syscall1(SYSCALL_NI, (ulong)print_task_by_name);
  replace_syscall2(SYSCALL_NJ, (ulong)scan_memory);
    
  //print_task_by_name(name);
  
  return 0;
}

// Exit of module
static void __exit exit_MalwareModule(void)
{  
  page_read_write((ulong)syscall_table);
  
  syscall_table[SYSCALL_NI] = (ulong)original_syscall1;
  syscall_table[SYSCALL_NJ] = (ulong)original_syscall2;
    
  page_read_only((ulong)syscall_table);
  printk(KERN_INFO "Syscall at offset %d : %p\n", SYSCALL_NI, (void *)syscall_table[SYSCALL_NI]);
  printk(KERN_INFO "Syscall at offset %d : %p\n", SYSCALL_NJ, (void *)syscall_table[SYSCALL_NJ]);
  printk(KERN_INFO "Custom syscall unloaded\n");
  
  printk(KERN_INFO "EXIT Malware Scanner Kernal Module.\n");
    
  return;
}

module_init(init_MalwareModule);
module_exit(exit_MalwareModule);

MODULE_AUTHOR("Jared Frees, Troy Ellison");
MODULE_LICENSE("GPL v2");
MODULE_DESCRIPTION("A kernel module used for malware scanning");
MODULE_VERSION("0.1");


