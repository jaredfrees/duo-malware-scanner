/*
  A kernel module to list process by their names. Print when loading the module.
  In the terminal, compile this module with "make" and load it with "sudo insmod process.ko". 
  Check the result of printk by “dmesg”
  Unload it with "sudo rmmod process.ko".
*/

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/init.h>
#include <linux/sched.h>
#include <asm/unistd.h>
#include <linux/list.h>
#include <linux/init_task.h>
#include <linux/syscalls.h>
#include <linux/kallsyms.h>
#include <linux/tty.h>
#include <linux/signal.h>

#define MAX_PROCESS_STRING_LEN 40

#include "print_to_tty.c"
#include "kill_tasks.c"
#include "print_tasks.c"

#ifndef __KERNEL__
#define __KERNEL__
#endif

#define SYS_CALL_TABLE "sys_call_table"
#define SYSCALL_NI __NR_tuxcall
#define SYSCALL_NJ __NR_mlockall

static unsigned long *syscall_table = NULL;

static unsigned long *original_syscall1 = NULL;
static unsigned long *original_syscall2 = NULL;


static int is_syscall_table(ulong *p)
{
  return ((p != NULL) && (p[__NR_close] == (ulong)sys_close));
}

static int page_read_write(ulong address)
{
  uint level;
  pte_t *pte = lookup_address(address, &level);

  if(pte->pte &~ _PAGE_RW)
          pte->pte |= _PAGE_RW;
  return 0;
}

static int page_read_only(ulong address)
{
  uint level;
  pte_t *pte = lookup_address(address, &level);
  pte->pte = pte->pte &~ _PAGE_RW;
  return 0;
}

static void replace_syscall1(ulong offset, ulong func_address)
{
  syscall_table = (ulong *)kallsyms_lookup_name(SYS_CALL_TABLE);
  if (is_syscall_table(syscall_table)) {
    printk(KERN_INFO "Syscall table address : %p\n", syscall_table);
    page_read_write((ulong)syscall_table);

    original_syscall1 = (ulong *)(syscall_table[offset]);
    printk(KERN_INFO "Syscall at offset %lu : %p\n", offset, original_syscall1);
    printk(KERN_INFO "Custom syscall address %p\n", (void *)func_address);
    
    syscall_table[offset] = func_address;
    
    printk(KERN_INFO "Syscall %lu hijacked\n", offset);
    printk(KERN_INFO "Syscall at offset %lu : %p\n", offset, (void *)syscall_table[offset]);
    page_read_only((ulong)syscall_table);
  }
}

static void replace_syscall2(ulong offset, ulong func_address)
{
  syscall_table = (ulong *)kallsyms_lookup_name(SYS_CALL_TABLE);
  if (is_syscall_table(syscall_table)) {
    printk(KERN_INFO "Syscall table address : %p\n", syscall_table);
    page_read_write((ulong)syscall_table);

    original_syscall2 = (ulong *)(syscall_table[offset]);
    printk(KERN_INFO "Syscall at offset %lu : %p\n", offset, (void *)original_syscall2);
    printk(KERN_INFO "Custom syscall address %p\n", (void *)func_address);
    
    syscall_table[offset] = func_address;
    
    printk(KERN_INFO "Syscall %lu hijacked\n", offset);
    printk(KERN_INFO "Syscall at offset %lu : %p\n", offset, (void *)syscall_table[offset]);
    page_read_only((ulong)syscall_table);
  }
}


// Initialization of module
static int __init init_MalwareModule(void)
{  
  printk(KERN_INFO "INIT Malware Scanner Kernal Module.\n");
  
  print_string("The module has been inserted");
  
  replace_syscall1(SYSCALL_NI, (ulong)print_task_by_name);
  replace_syscall2(SYSCALL_NJ, (ulong)kill_processes);
  
  return 0;
}

// Exit of module
static void __exit exit_MalwareModule(void)
{  
  page_read_write((ulong)syscall_table);
  
  syscall_table[SYSCALL_NI] = (ulong)original_syscall1;
  syscall_table[SYSCALL_NJ] = (ulong)original_syscall2;
    
  page_read_only((ulong)syscall_table);
  printk(KERN_INFO "Syscall at offset %d : %p\n", SYSCALL_NI, (void *)syscall_table[SYSCALL_NI]);
  printk(KERN_INFO "Syscall at offset %d : %p\n", SYSCALL_NJ, (void *)syscall_table[SYSCALL_NJ]);
  printk(KERN_INFO "Custom syscall unloaded\n");
  
  printk(KERN_INFO "EXIT Malware Scanner Kernal Module.\n");
    
  return;
}

module_init(init_MalwareModule);
module_exit(exit_MalwareModule);

MODULE_AUTHOR("Jared Frees, Troy Ellison");
MODULE_LICENSE("GPL v2");
MODULE_DESCRIPTION("A kernel module used for malware scanning");
MODULE_VERSION("0.1");


